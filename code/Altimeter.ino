#define _CSPin 9
#define _SDAPin 6
#define _SCKPin 5
#define _ResetPin 8
#define _BatPin A1
#define _ButtPin 7
#define _ButtInt 4 // Номер прерывания кнопки.

#define _PwrDispPin 4
#define _PwrBaroPin 15

#define _LedDispPin 16 //PORTB2


#define MS5611_ADDRESS                (0x77)
#define MS5611_CMD_ADC_READ           (0x00)
#define MS5611_CMD_RESET              (0x1E)
#define MS5611_CMD_CONV_D1            (0x40)
#define MS5611_CMD_CONV_D2            (0x50)
#define MS5611_CMD_READ_PROM          (0xA2)
#define uosr                          (0x08)

#define buffersize  100
#define pgm     pgm_read_byte

#include <Wire.h>
#include <math.h>
#include <avr/pgmspace.h>
#include <avr/sleep.h>
#include <avr/power.h>


static const byte DIG24[][168] PROGMEM =
{
  {0x00, 0x00, 0x00, 0x80, 0xc0, 0xf0, 0xf8, 0xfc, 0xfe, 0xfe, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0xfe, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0xf0, 0xfc, 0xff, 0xff, 0xff, 0x3f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0f, 0xff, 0xff, 0xff, 0xfe, 0xf0, 0x00, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xff, 0xff, 0xff, 0x7f, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0x7f, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7f, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xfc, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0x7f, 0x3f, 0x1f, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xfe, 0x7e, 0x3e, 0x3e, 0x3e, 0x3e, 0x7e, 0xfe, 0xfc, 0xfc, 0xf8, 0xf0, 0xc0, 0x80, 0x00, 0x00, 0xf8, 0xfe, 0xff, 0xff, 0xff, 0x3f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 0xf8, 0xfc, 0xff, 0xff, 0xff, 0x3f, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf8, 0xfc, 0xfe, 0xff, 0x7f, 0x3f, 0x0f, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfe, 0xff, 0xff, 0x7f, 0x0f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e },
  { 0x00, 0x00, 0x80, 0xc0, 0xf0, 0xf8, 0xfc, 0xfe, 0xfe, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0xfe, 0xfe, 0xfc, 0xfc, 0xf0, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xe0, 0xe0, 0xf8, 0xff, 0xff, 0xff, 0x3f, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x3f, 0x7f, 0xff, 0xfd, 0xfc, 0xf0, 0xe0, 0xe0, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x01, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0x7f, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7f, 0x3f, 0x3f, 0x1f, 0x0f, 0x03, 0x01, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xf0, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfe, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfe, 0xff, 0x7f, 0x1f, 0x07, 0x01, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfe, 0xff, 0x7f, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xf8, 0xfe, 0xff, 0xff, 0xff, 0xe7, 0xe1, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe0, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xe0, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x3f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x1f, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0xf8, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0xf0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf8, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0x7f, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7f, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xf8, 0xfc, 0xfc, 0x7e, 0x3e, 0x1e, 0x1e, 0x1e, 0x3e, 0x7e, 0xfc, 0xf8, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xfc, 0xff, 0xff, 0xff, 0x0f, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3f, 0x3f, 0x3f, 0x3c, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x0f, 0x07, 0x07, 0x03, 0x03, 0x07, 0x07, 0x0f, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0xf8, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xf8, 0xff, 0xff, 0xff, 0x7f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0x7f, 0x7e, 0x7e, 0x7e, 0x7e, 0x7f, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x01, 0x00, 0x00 },
  { 0x00, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0xbe, 0xfe, 0xfe, 0xfe, 0xfe, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfe, 0xff, 0x7f, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xf0, 0xfe, 0xff, 0xff, 0x7f, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfc, 0xff, 0xff, 0xff, 0x1f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xfe, 0xff, 0xff, 0xff, 0x7f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0xfe, 0xfe, 0xfc, 0xf8, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0x3f, 0x7f, 0xff, 0xff, 0xf0, 0xe0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0x7f, 0x1f, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xe0, 0xf8, 0xfc, 0xfd, 0xff, 0x7f, 0x3f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x3f, 0x7f, 0xff, 0xfd, 0xf8, 0xf8, 0xe0, 0xc0, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x01, 0x03, 0x0f, 0x1f, 0x3f, 0x3f, 0x7f, 0x7f, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7f, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x01, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xfe, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0xfe, 0xfc, 0xf8, 0xf8, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xfe, 0xff, 0xff, 0xff, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x1f, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0xf0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xf0, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x07, 0x03, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x7e, 0xfe, 0xfe, 0xfe, 0xfe, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xf0, 0xfe, 0xff, 0xff, 0x7f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0f, 0x1f, 0x3f, 0x7f, 0x7f, 0x7f, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3f, 0x7f, 0x7f, 0x7f, 0x7f, 0x3f, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
};

static const byte BAT[][10] PROGMEM =
{
  {0x7f, 0x41, 0x63, 0x55, 0x49, 0x55, 0x63, 0x41, 0x7f, 0x1c},
  {0x7f, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x7f, 0x1c},
  {0x7f, 0x7d, 0x79, 0x71, 0x61, 0x41, 0x41, 0x41, 0x7f, 0x1c},
  {0x7f, 0x7f, 0x7f, 0x7d, 0x79, 0x71, 0x61, 0x41, 0x7f, 0x1c},
  {0x7f, 0x7f, 0x7f, 0x7f, 0x7d, 0x79, 0x71, 0x61, 0x7f, 0x1c},
  {0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x1c}
};

static const byte DIG3[][3] PROGMEM =
{
  {0x3e, 0x41, 0x3e},
  {0x42, 0x7f, 0x40},
  {0x72, 0x49, 0x46},
  {0x22, 0x49, 0x36},
  {0x0f, 0x08, 0x7f},
  {0x2f, 0x49, 0x31},
  {0x3e, 0x49, 0x32},
  {0x01, 0x01, 0x7f},
  {0x36, 0x49, 0x36},
  {0x26, 0x49, 0x3e}
  //{0x08, 0x08, 0x08}; // Минус проще нарисовать чем тянуть из памяти
};

#define menu_count 3
static const byte MENU[][22] PROGMEM =
{
  {0x7f, 0x49, 0x49, 0x00, 0x7f, 0x09, 0x76, 0x00, 0x7f, 0x09, 0x76, 0x00, 0x3e, 0x41, 0x3e, 0x00, 0x7f, 0x09, 0x76, 0x00, 0x40, 0x00   },
  // 0 - error
  {0x7e, 0x01, 0x0e, 0x01, 0x7e, 0x00, 0x7f, 0x49, 0x41, 0x00, 0x7f, 0x06, 0x18, 0x7f, 0x00, 0x3f, 0x40, 0x40, 0x3f, 0x00, 0x00, 0x00 },
  // 1 - menu
  {0x26, 0x49, 0x32, 0x00, 0x7f, 0x09, 0x06, 0x00, 0x7f, 0x49, 0x41, 0x00, 0x7f, 0x49, 0x41, 0x00, 0x7f, 0x41, 0x3e, 0x00, 0x00, 0x00   },
  // 2 - speed
  {0x01, 0x7f, 0x01, 0x00, 0x7f, 0x49, 0x41, 0x00, 0x7f, 0x02, 0x0c, 0x02, 0x7f, 0x00, 0x7f, 0x09, 0x06, 0x00, 0x02, 0x05, 0x02, 0x00   },
  // 3 - temp
  {0x3e, 0x41, 0x3e, 0x00, 0x7f, 0x09, 0x01, 0x00, 0x7f, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00   },
  // 4 - off
  {0x7f, 0x40, 0x40, 0x00, 0x3e, 0x41, 0x3e, 0x00, 0x7e, 0x09, 0x7e, 0x00, 0x7f, 0x41, 0x3e, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00  },
  // 5 - load
  {0x00, 0x7e, 0x81, 0x7e, 0x00, 0xff, 0x10, 0xec, 0x00, 0x02, 0xb9, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00   }
  // 6 - ok?
};
#define menuok 6
#define loadmenu 5

int menu_poz = 0;
byte btst = 0;
byte olddig1 = 12;
byte olddig2 = 12;
byte olddig3 = 12;
byte olddig4 = 12;
byte oldstatdig1 = 12;
byte oldstatdig2 = 12;
byte oldstatdig3 = 12;
byte oldstatdig4 = 12;

boolean altlock = 0;
boolean speedlock = 0;
boolean dispstat = 0;
boolean ledstat = 0;
boolean onmenu = false;

unsigned long sleeptimer = 0;
unsigned long phisttimer = 0;
unsigned long disptimer = 0;
unsigned long zgtimer = 0; // таймер сброса на ноль
unsigned long splcktimer = 0; // таймер блокировки по скорости
unsigned long altlcktimer = 0; // таймер блокировки по высоте
unsigned long stattimer = 0;  // таймер опроса статуса
volatile unsigned long buttptimer = 0; //таймкод нажатия кнопки
volatile unsigned long buttrtimer = 0; //таймкод отпускания кнопки
volatile byte butt_dp = 150;
volatile byte butt_deb = 40;
volatile int butt_hold = 1000;
volatile int butt_hold_long = 3000;
volatile byte butt_fl = 0;
volatile byte butt_pr = 0;
volatile byte butt_re = 0;
volatile byte butt_h = 0;
volatile byte butt_hl = 0;

//press
//presstime
volatile unsigned long raw_baro[buffersize][2];
//volatile double alt[buffersize];
volatile int8_t baro_w = 0;
volatile int8_t baro_r = 0;
int altitude = 0;
int vspeed = 0;
int temperature = 0;
volatile unsigned long baro_temperature = 0;
unsigned long zero = 10000;
volatile double speed_f = 0;
volatile double speed_s = 0;
volatile byte screen_mode = 0;

uint16_t fc[6];
int32_t TEMP2;
int64_t OFF2;
int64_t SENS2;


void screen()
{
  //Нужен основной дисплей 0
  //
}

void pwroff()
{

}

void stat_val(int val)
{
  byte dig1 = 0;
  byte dig2 = 0;
  byte dig3 = 0;
  byte dig4 = 0;
  byte minus = 0;
  if (val < 0)
  {
    minus = 1;
  }
  val = abs(val);
  dig1 = val / 1000;
  dig2 = (val - (dig1 * 1000)) / 100;
  dig3 = (val - (dig1 * 1000) - (dig2 * 100)) / 10;
  dig4 = val - (dig1 * 1000) - (dig2 * 100) - (dig3 * 10);
  if (val < 10)
  {
    dig1 = 11;
    dig2 = 11;
    if (minus == 1) dig3 = 10;
    else dig3 = 11;
  }
  else
  {
    if (val < 100)
    {
      dig1 = 11;
      if (minus == 1) dig2 = 10;
      else dig2 = 11;
    }
    else {
      if (val < 1000)
      {
        if (minus == 1) dig1 = 10;
        else dig1 = 11;
      }
    }
  }
  if (olddig1 != dig1)
  {
    glcddig3(dig1, 1);
    oldstatdig1 = dig1;
  }
  if (olddig2 != dig2)
  {
    glcddig3(dig2, 2);
    oldstatdig2 = dig2;
  }
  if (olddig3 != dig3)
  {
    glcddig3(dig3, 3);
    oldstatdig3 = dig3;
  }
  if (olddig4 != dig4)
  {
    glcddig3(dig4, 4);
    oldstatdig4 = dig4;
  }
}

void glcddig3(byte dig, byte poz)
{
  glcdline(0);
  if (poz == 1)  glcdcolumn(67);
  if (poz == 2)  glcdcolumn(71);
  if (poz == 3)  glcdcolumn(77);
  if (poz == 4)  glcdcolumn(81);
  if (dig <= 10)
  {
    for (int index = 0; index < 3; index++)
    {
      byte payload = pgm(&(DIG3[dig][index]));
      glcddata(payload);
    }
  }
  else
  {
    for (int index = 0; index < 3; index++)
    {
      glcddata(0x00);
    }
  }
}

void ButtInt()
{
  detachInterrupt(_ButtInt);
  //По умолчанию ждем нажатия кнопки
  attachInterrupt(_ButtInt, ButtP, FALLING);
}

void ButtWrk()
{
  if (butt_fl == 1) //проверяем необходимость обработки
  {
    if (butt_pr == 1 && butt_re == 1) // Кнопка нажата и отпущена
    {
      if (onmenu && butt_h == 0 && butt_hl == 0)     menulist(); //
      if (butt_h == 1)// Если кнопка удерживалась и
      {
        if (onmenu)
        { //мы в меню
          menuaction(menu_poz);
        }
        else
        { //мы не в меню
          menuin();
          menu_poz = 2;
          glcdmenu(2);
        }
      }
      butt_h = 0;
      butt_hl = 0;
    }
    if (butt_pr == 1 && butt_re == 0) // Кнопка нажата и не отпущена
    {

    }
    butt_fl = 0; // Обработка завершена и более не требуется
  }
  if (butt_pr == 1 && butt_re == 0 && (millis() - buttptimer) > butt_hold && butt_h == 0 && butt_hl == 0) //Проверяем, что кнопка удерживается.
  { // Если кнопка удерживается
    if (!onmenu)    glcdmenu(1);
    else glcdmenu(menuok);
    butt_h = 1;
  }
  if (butt_pr == 1 && butt_re == 0 && (millis() - buttptimer) > butt_hold_long && butt_hl == 0) //Проверяем, что кнопка удерживается.
  { // Если кнопка долго удерживается
    if (!onmenu)
    {
      glcdmenuclr();
      ledsw();
    }
    else menuout();
    butt_hl = 1;
    butt_h = 0;
  }
}

void error()
{
  glcdmenu(0);
}

void glcdmenu(int poz)
{ //Позиция меню 35-57 22х8
  glcdline(0);
  glcdcolumn(35);
  for (int index = 0; index < 22; index++)
  {
    byte payload = pgm(&(MENU[poz][index]));
    glcddata(payload);
  }
  //menu_poz = poz;
}

void glcdmenuclr()
{ //Позиция меню 35-57 22х8
  glcdline(0);
  glcdcolumn(35);
  for (int index = 0; index < 22; index++)
  {
    glcddata(0x00);
  }
}

void menuin()
{
  onmenu = true;
}

void menuout()
{
  onmenu = false;
  glcdmenuclr();
}

void menulist()
{
  menu_poz++;
  if (menu_poz > menu_count) menuout();
  else glcdmenu(menu_poz);
}

void menuaction(int poz)
{
  if (poz == 2)
  {
    glcdalt(vspeed);
    disptimer = millis();
    menuout();
  }
  else
  {
    if (poz == 3)
    {
      glcdalt(baro_temperature);
      disptimer = millis();
      menuout();
    }
    else error();
  }
}

void ButtP()
{
  detachInterrupt(_ButtInt); //отключем прерывание по кнопке до конца обработки.
  if (( millis() - buttptimer) > butt_deb && ( millis() - buttrtimer) > butt_deb) //если кнопка в прошлый раз была нажата не менее чем антидребезг
  {
    butt_fl = 1;//ставим флаг необходимости обработки кнопки
    butt_pr = 1;//запоминаем что кнопка нажата
    butt_re = 0;
    buttptimer = millis();//запоминаем время нажатия кнопки
  }
  attachInterrupt(_ButtInt, ButtR, RISING);
}

void ButtR()
{
  detachInterrupt(_ButtInt);
  if (( millis() - buttptimer) > butt_deb && butt_pr == 1)
  {
    butt_fl = 1;//ставим флаг необходимости обработки кнопки
    butt_re = 1;//запоминаем что кнопка отпущена
    buttrtimer = millis();//запоминаем время нажатия кнопки
  }
  attachInterrupt(_ButtInt, ButtP, FALLING);
}

void ledsw()
{
  //Лампочка
  //{0x49, 0x2a, 0x00, 0x1c, 0x22, 0x41, 0x55, 0x49, 0x2a, 0x1c, 0x1c, 0x08 };
  glcdline(0);
  glcdcolumn(17);
  if (!ledstat)
  {
    ledon();
    glcddata(0x49);
    glcddata(0x2a);
    glcddata(0x00);
    glcddata(0x1c);
    glcddata(0x22);
    glcddata(0x41);
    glcddata(0x55);
    glcddata(0x49);
    glcddata(0x2a);
    glcddata(0x1c);
    glcddata(0x1c);
    glcddata(0x08);
  }
  else
  {
    ledoff();

    for (int index = 0; index < 12; index++)
    {
      glcddata(0x00);
    }
  }
}

void ledon()
{
  ledstat = 1;
  PORTB |=   (1 << PB2);             // установка бита 1
}

void ledoff()
{
  ledstat = 0;
  PORTB &= ~ (1 << PB2);             // сброс бита 1
}

void wakeup()
{
  digitalWrite(_PwrBaroPin, HIGH);
  btst = 6;
  olddig1 = 12;
  olddig2 = 12;
  olddig3 = 12;
  olddig4 = 12;
  glcdstart();
  batstat();
  glcdalt(altitude);
  sleeptimer = millis();
  ButtInt();
}

void startsleep()
{
  detachInterrupt(_ButtInt);
  glcdstop();
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  attachInterrupt(_ButtInt, wakeup, LOW);
  digitalWrite(_PwrBaroPin, LOW);
  sleep_enable();
  sleep_mode();
  sleep_disable();
}



void glcdtemp()
{
  glcdline(0);
  glcdcolumn(85);
  // {0x3e, 0x41, 0x41, 0x22, 0x00, 0x02, 0x05, 0x02, 0x00, 0x00};
  glcddata(0x3e);
  glcddata(0x41);
  glcddata(0x41);
  glcddata(0x22);
  glcddata(0x00);
  glcddata(0x02);
  glcddata(0x05);
  glcddata(0x02);
  glcddata(0x00);
  glcddata(0x00);
}

void glcdspeed()
{
  glcdline(0);
  glcdcolumn(85);
  // {0x0f, 0x02, 0x04, 0x42, 0x2f, 0x10, 0x08, 0x34, 0x4a, 0x48   };
  glcddata(0x0f);
  glcddata(0x02);
  glcddata(0x04);
  glcddata(0x42);
  glcddata(0x2f);
  glcddata(0x10);
  glcddata(0x08);
  glcddata(0x34);
  glcddata(0x4a);
  glcddata(0x48);
}

void glcdbat(byte stat)
{
  if (stat != btst)
  {
    glcdline(0);
    glcdcolumn(0);
    for (int index = 0; index < 10; index++)
    {
      {
        byte payload = pgm(&(BAT[stat][index]));
        glcddata(payload);
      }
    }
    btst = stat;
  }
}

void batstat()
{
  //660 - 3.2v - batfail
  //715 - 3.5v - batlow
  //765 - 3.75v - bat 30%
  //785 - 3.85v - bat 50%
  //800 - 3.92v - bat 80%
  //847 - 4.15v - bat 100%
  int val = analogRead(_BatPin);
  if (val >= 825) glcdbat(5);
  else if (val >= 800) glcdbat(4);
  else if (val >= 775) glcdbat(3);
  else if (val >= 755) glcdbat(2);
  else if (val >= 735) glcdbat(1);
  else if (val >= 710) glcdbat(0);
}

void glcdlock(byte stat)
{
  glcdline(0);
  glcdcolumn(11);
  //byte locked[] = {0x7e, 0x79, 0x69, 0x79, 0x7e};
  if (stat == 0)
  {
    for (int index = 0; index < 5; index++)
    {
      glcddata(0x00);
    }
  }
  if (stat == 1)
  {
    glcddata(0x7e);
    glcddata(0x79);
    glcddata(0x69);
    glcddata(0x79);
    glcddata(0x7e);
  }
}

void glcdalt(int val)
{
  byte dig1 = 0;
  byte dig2 = 0;
  byte dig3 = 0;
  byte dig4 = 0;
  byte minus = 0;
  if (val < 0)
  {
    minus = 1;
  }
  val = abs(val);
  dig1 = val / 1000;
  dig2 = (val - (dig1 * 1000)) / 100;
  dig3 = (val - (dig1 * 1000) - (dig2 * 100)) / 10;
  dig4 = val - (dig1 * 1000) - (dig2 * 100) - (dig3 * 10);
  if (val < 10)
  {
    dig1 = 11;
    dig2 = 11;
    if (minus == 1) dig3 = 10;
    else dig3 = 11;
  }
  else
  {
    if (val < 100)
    {
      dig1 = 11;
      if (minus == 1) dig2 = 10;
      else dig2 = 11;
    }
    else {
      if (val < 1000)
      {
        if (minus == 1) dig1 = 10;
        else dig1 = 11;
      }
    }
  }
  if (olddig1 != dig1)
  {
    glcddig24(dig1, 1);
    olddig1 = dig1;
  }
  if (olddig2 != dig2)
  {
    glcddig24(dig2, 2);
    olddig2 = dig2;
  }
  if (olddig3 != dig3)
  {
    glcddig24(dig3, 3);
    olddig3 = dig3;
  }
  if (olddig4 != dig4)
  {
    glcddig24(dig4, 4);
    olddig4 = dig4;
  }
}

void glcddig24(byte dig, byte poz)
{
  byte line = 1;
  byte column = 0;
  column = (poz - 1) * 24;
  glcdline(line);
  glcdcolumn(column);
  if (dig <= 10)
  {
    for (int index = 0; index < 168; index++)
    {
      {
        if ((index / 24) > line - 1)
        {
          line = line + 1;
          glcdline(line);
          glcdcolumn(column);
        }
        byte payload = pgm(&(DIG24[dig][index]));
        glcddata(payload);
      }
    }
  }
  else
  {
    for (int index = 0; index < 168; index++)
    {
      {
        if ((index / 24) > line - 1)
        {
          line = line + 1;
          glcdline(line);
          glcdcolumn(column);
        }
        glcddata(0x00);
      }
    }
  }
}

void glcdline(byte line)
{
  if (line < 0) {
    line = 0;
  }
  if (line > 8) {
    line = 8;
  }
  line = 176 + line;
  glcdcommand(line);  //set line
}

void glcdcolumn(byte payload)
{
  if (payload < 0) {
    payload = 0;
  }
  if (payload > 95) {
    payload = 95;
  }

  byte lower = 0x0F;
  byte upper = 0x70;

  lower = payload & 0x0F;
  upper = payload & 0x70;

  upper = upper >> 4;

  upper = 0x10 | upper;

  glcdcommand(upper);
  glcdcommand(lower);
}

void glcdcommand(byte payload)
{
  //select graphicsLCD
  digitalWrite(_CSPin, LOW);
  digitalWrite(_SDAPin, LOW);
  digitalWrite(_SCKPin, HIGH);
  digitalWrite(_SCKPin, LOW);
  //write payload 8 bits
  for (int i = 7; i >= 0; i--)
  {
    digitalWrite(_SDAPin, (payload >> i) & 1);
    //toggle clock
    digitalWrite(_SCKPin, HIGH);
    digitalWrite(_SCKPin, LOW);
  }
  //turn off graphicsLCD cs
  digitalWrite(_CSPin, HIGH);
}

void glcddata(byte payload)
{
  //select graphicsLCD
  digitalWrite(_CSPin, LOW);
  digitalWrite(_SDAPin, HIGH);
  digitalWrite(_SCKPin, HIGH);
  digitalWrite(_SCKPin, LOW);
  //write payload 8 bits
  for (int i = 7; i >= 0; i--)
  {
    digitalWrite(_SDAPin, (payload >> i) & 1);
    //toggle clock
    digitalWrite(_SCKPin, HIGH);
    digitalWrite(_SCKPin, LOW);
  }
  //turn off graphicsLCD cs
  digitalWrite(_CSPin, HIGH);
}

void glcdclear()
{
  //display off
  //glcdcommand(0xAE);
  for (int i = 0; i < 864; i++)
  {
    glcddata(0x00);
  }
  glcdcommand(0xB0);  //set page address
  glcdcommand(0x10);  //set col=0 upper 3 bits
  glcdcommand(0x00);  //set col=0 lower 4 bits
  glcdcommand(0x40);  //set row 0
  //display on
  //glcdcommand(0xAF);
}

void glcdOff()
{
  glcdcommand(0xAE);
}

void glcdOn()
{
  glcdcommand(0xAF);
}

void glcdNorm()
{
  glcdcommand(0xA6);
}

void glcdInverse()
{
  glcdcommand(0xA7);
}

void glcdcontrast(byte con)
{
  if (con < 0) {
    con = 0;
  }
  if (con > 32) {
    con = 32;
  }

  con = con | 0x80;
  glcdcommand(con);
}


void glcdAllPointsOn()
{
  glcdcommand(0xA5);
}


void glcdAllPointsOff()
{
  glcdcommand(0xA4);
}


void glcdsoftReset()
{
  glcdcommand(0xE2);  //reset
}


void glcdhardReset()
{
  digitalWrite(_ResetPin, LOW);
  delay(5);
  digitalWrite(_ResetPin, HIGH);
  delay(5);
}

void glcdstart()
{
  digitalWrite(_PwrDispPin, HIGH);
  //digitalWrite(_LedDispPin, HIGH);
  //disable graphicsLCD to start with
  digitalWrite(_CSPin, HIGH);
  digitalWrite(_SDAPin, LOW);
  digitalWrite(_SCKPin, LOW);

  // set reset pin to start graphicsLCD
  digitalWrite(_ResetPin, HIGH);

  glcdcommand(0xE2);  //reset
  delay(10);
  glcdcommand(0xA4);  //power save off
  glcdcommand(0x2F);  //power control set
  glcdcommand(0xB0);  //set page address
  glcdcommand(0x10);  //set col=0 upper 3 bits
  glcdcommand(0x00);  //set col=0 lower 4 bits
  glcdcommand(0xAF);  //graphicsLCD display on

  glcdclear();
  glcdcontrast(10);
}

void glcdstop()
{
  digitalWrite(_PwrDispPin, LOW);
  ledoff();
  digitalWrite(_CSPin, LOW);
  digitalWrite(_SDAPin, LOW);
  digitalWrite(_SCKPin, LOW);
  digitalWrite(_ResetPin, LOW);
}

//------------------------------------------------------------
//------------------START-------------------------------------
void setup()
{
  pinMode(_LedDispPin, OUTPUT);
  ledon();
  pinMode(_PwrDispPin, OUTPUT);
  pinMode(_PwrBaroPin, OUTPUT);
  pinMode(_CSPin, OUTPUT);
  pinMode(_SDAPin, OUTPUT);
  pinMode(_SCKPin, OUTPUT);
  pinMode(_ResetPin, OUTPUT);
  //Serial.begin(57600);

  pinMode(_ButtPin, INPUT_PULLUP);
  //Подаём питание на бародатчик
  digitalWrite(_PwrBaroPin, HIGH);
  MS5611init();
  glcdstart();
  glcdmenu(loadmenu);
  glcdlock(0);
  batstat();
  MS5611Data();
  zero = raw_baro [baro_r][0];
  MS5611Data();
  glcdalt(altitude);
  MS5611Data();
  ButtInt();
  MS5611Data();
  zero = raw_baro [baro_r][0];
  glcdmenuclr();
  stat_val(speed_s);
  glcdspeed();
  ledoff();
}


void loop()
{
  if (millis() - phisttimer > 500) {
    phisttimer = millis();
    MS5611Data();
  }
  if (millis() - disptimer > 500) {
    glcdalt(altitude);
    stat_val(speed_s);
    glcdspeed();
  }
  if (millis() - zgtimer > 20000 && speedlock == 0 && altlock == 0) {
    zgtimer = millis();
    setzero();
    glcdlock(0);
  }
  if (millis() - stattimer > 20000) {
    //stat_val(speed_s);
    //glcdspeed();
    batstat();
    stattimer = millis();
  }
  if (millis() - sleeptimer > 60000)
  {
    detachInterrupt(_ButtInt);
    glcdstop();
    attachInterrupt(_ButtInt, wakeup, LOW);
  }
  if (millis() - sleeptimer > 3600000)
  {
    startsleep();
  }
  ButtWrk();
}




void MS5611init()
{
  Wire.begin();
  Wire.beginTransmission(MS5611_ADDRESS);
  Wire.write(MS5611_CMD_RESET);
  Wire.endTransmission();
  delay(100);
  for (uint8_t offset = 0; offset < 6; offset++)
  {
    fc[offset] = readRegister16(MS5611_CMD_READ_PROM + (offset * 2));
  }
}

uint16_t readRegister16(uint8_t reg)
{
  uint16_t value;
  Wire.beginTransmission(MS5611_ADDRESS);
  Wire.write(reg);
  Wire.endTransmission();
  Wire.beginTransmission(MS5611_ADDRESS);
  Wire.requestFrom(MS5611_ADDRESS, 2);
  while (!Wire.available()) {};
  uint8_t vha = Wire.read();
  uint8_t vla = Wire.read();
  Wire.endTransmission();
  value = vha << 8 | vla;
  return value;
}


void MS5611Data()
{
  //Вычисляем ячейку для записи
  if (baro_w >= (buffersize - 1))
  {
    baro_w = 0;
  }
  else
  {
    baro_w++;
  }
  //Запрос температуры.
  Wire.beginTransmission(MS5611_ADDRESS);
  Wire.write(MS5611_CMD_CONV_D2 + uosr);
  Wire.endTransmission();
  //Задержка на вызов считывания температуры.
  delay(10);
  //Задержка на вызов считывания температуры.
  Wire.beginTransmission(MS5611_ADDRESS);
  Wire.write(MS5611_CMD_ADC_READ);
  Wire.endTransmission();
  Wire.beginTransmission(MS5611_ADDRESS);
  Wire.requestFrom(MS5611_ADDRESS, 3);
  while (!Wire.available()) {};
  uint8_t vxa = Wire.read();
  uint8_t vha = Wire.read();
  uint8_t vla = Wire.read();
  Wire.endTransmission();
  baro_temperature = ((int32_t)vxa << 16) | ((int32_t)vha << 8) | vla;
  //Запрос давления.
  Wire.beginTransmission(MS5611_ADDRESS);
  Wire.write(MS5611_CMD_CONV_D1 + uosr);
  Wire.endTransmission();
  //Задержка на вызов считывания давления.
  delay(10);
  //Задержка на вызов считывания давления.
  //Считывание давления.
  raw_baro [baro_w][1] = millis();
  Wire.beginTransmission(MS5611_ADDRESS);
  Wire.write(MS5611_CMD_ADC_READ);
  Wire.endTransmission();
  Wire.beginTransmission(MS5611_ADDRESS);
  Wire.requestFrom(MS5611_ADDRESS, 3);
  while (!Wire.available()) {};
  //uint8_t vxa = Wire.read();
  //uint8_t vha = Wire.read();
  //uint8_t vla = Wire.read();
  vxa = Wire.read();
  vha = Wire.read();
  vla = Wire.read();
  Wire.endTransmission();
  raw_baro [baro_w][0] = ((int32_t)vxa << 16) | ((int32_t)vha << 8) | vla;
  //Выставляем ячейку для чтения
  baro_r = baro_w;
  //Задержка на вызов повторного считывания температуры.


  // Расчёт показателей температуры
  int32_t dT = baro_temperature - (uint32_t)fc[4] * 256;
  int32_t TEMP = 2000 + ((int64_t) dT * fc[5]) / 8388608;
  TEMP2 = 0;
  if (TEMP < 2000)
  {
    TEMP2 = (dT * dT) / (2 << 30);
  }
  temperature = TEMP - TEMP2;

  //Расчёт показателей давления
  int64_t OFF = (int64_t)fc[1] * 65536 + (int64_t)fc[3] * dT / 128;
  int64_t SENS = (int64_t)fc[0] * 32768 + (int64_t)fc[2] * dT / 256;

  OFF2 = 0;
  SENS2 = 0;

  if (TEMP < 2000)
  {
    OFF2 = 5 * ((TEMP - 2000) * (TEMP - 2000)) / 2;
    SENS2 = 5 * ((TEMP - 2000) * (TEMP - 2000)) / 4;
  }

  if (TEMP < -1500)
  {
    OFF2 = OFF2 + 7 * ((TEMP + 1500) * (TEMP + 1500));
    SENS2 = SENS2 + 11 * ((TEMP + 1500) * (TEMP + 1500)) / 2;
  }

  OFF = OFF - OFF2;
  SENS = SENS - SENS2;

  raw_baro [baro_r][0] = (raw_baro [baro_r][0] * SENS / 2097152 - OFF) / 32768;
  //Расчитываем высоту
  setalt();
  //glcdalt(phisttimer-millis());
  //Расчитываем вертикальную скорость
  setspeed();
}

void setzero()
{
  unsigned long p = 0;
  int8_t n = 0;
  for (int8_t i = 40; i < 50; ++i )
  {
    int8_t h = baro_r - i;
    if (h < 0)
    {
      h = buffersize - i;
    }
    if (raw_baro [h][0] > 0)
    {
      p = p + raw_baro [h][0];
      n++;
    }
  }
  if (n > 1) zero = p / n;
  else zero = raw_baro [baro_r][0];
}

void setspeed()
{
  double a[4];
  double t[4];
  for (int8_t i = 0; i < 4; ++i )
  {
    int8_t h = baro_r - i;
    if (h < 0)
    {
      h = buffersize - i;
    }
    if (altitude == 0) return;
    a[i] = calcalt(raw_baro [h][0]);
    t[i] = (double)raw_baro [h][1] / 1000;

  }
  speed_f = (a[0] - a[1]) / (t[0] - t[1]);
  speed_s = (a[1] - a[2]) / (t[1] - t[2]);
  speed_s = speed_s + (a[2] - a[3]) / (t[2] - t[3]);
  speed_s = speed_s + (a[0] - a[3]) / (t[0] - t[3]);
  speed_s = speed_s + speed_f;
  speed_s = speed_s / 4;
  vspeed = roundf(speed_s);
  if (speed_s > 2.0 || speed_s < -1.0)
  {
    speedlock = 1;
    glcdlock(1);
    splcktimer = millis();
    sleeptimer = millis();
    zgtimer = millis();
  }
  else
  {
    unsigned long splcktime = millis() - splcktimer;
    if ((speed_s > -0.1 || speed_s < 0.1) && (splcktime > 10000))
    {
      speedlock = 0;
    }
  }
}

double calcalt(unsigned long pressure)
{
  double alt = (44330.0f * (1.0f - pow((double)pressure / (double)zero, 0.1902949f)));
  return (alt);
}

void setalt()
{
  //alt[baro_r] = (44330.0f * (1.0f - pow((double)raw_baro [baro_r][0] / (double)zero, 0.1902949f)));
  double alt = calcalt(raw_baro [baro_r][0]);
  if ((alt > (-0.9)) && (alt < 0.9)) altitude = 0;
  altitude = roundf(alt);
  if (altitude > 50)
  {
    altlock = 1;
    glcdlock(1);
    altlcktimer = millis();
    sleeptimer = millis();
    zgtimer = millis();
  }
  else
  {
    //unsigned long altlcktime = millis() - altlcktimer;
    if ((altitude < 30) && (millis() - altlcktimer > 60000))
    {
      altlock = 0;
    }
  }
}
